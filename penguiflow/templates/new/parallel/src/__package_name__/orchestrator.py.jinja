"""Main orchestrator for {{ project_name }}."""

from __future__ import annotations

import logging
import secrets
from dataclasses import dataclass
from typing import Any

from penguiflow.errors import FlowError
from penguiflow.planner import PlannerFinish, PlannerPause

from .clients.memory import MemoryClient
from .config import Config
from .models import FinalDocuments
from .planner import PlannerBundle, build_planner
from .telemetry import AgentTelemetry

_LOGGER = logging.getLogger(__name__)


class {{ class_name }}FlowError(RuntimeError):
    """Raised when planner execution fails."""

    def __init__(self, flow_error: FlowError | str) -> None:
        message = flow_error.message if isinstance(flow_error, FlowError) else str(flow_error)
        super().__init__(message)
        self.flow_error = flow_error


@dataclass
class AgentResponse:
    """Response envelope returned by the orchestrator."""

    answer: str
    trace_id: str
    metadata: dict[str, Any] | None = None


class {{ class_name }}Orchestrator:
    """Production-style orchestrator using ReactPlanner with parallel plan."""

    def __init__(
        self,
        config: Config,
        *,
        telemetry: AgentTelemetry | None = None,
    ) -> None:
        self._config = config
        self._memory = MemoryClient(config.memory_base_url)
        self._telemetry = telemetry or AgentTelemetry(
            flow_name="{{ project_name }}",
            logger=_LOGGER,
        )

        planner_bundle: PlannerBundle = build_planner(
            config,
            event_callback=self._telemetry.record_planner_event,
        )
        self._planner = planner_bundle.planner
        self._started = True

    async def execute(
        self,
        query: str,
        *,
        tenant_id: str,
        user_id: str,
        session_id: str,
    ) -> AgentResponse:
        """Execute the ReactPlanner with memory integration."""
        trace_id = secrets.token_hex(8)

        conscious = await self._memory.start_session(
            tenant_id=tenant_id,
            user_id=user_id,
            session_id=session_id,
        )
        retrieval = await self._memory.auto_retrieve(
            tenant_id=tenant_id,
            user_id=user_id,
            session_id=session_id,
            prompt=query,
        )

        llm_context = {
            "conscious_memories": conscious.get("conscious", []),
            "retrieved_memories": retrieval.get("snippets", []),
        }
        tool_context = {
            "tenant_id": tenant_id,
            "user_id": user_id,
            "session_id": session_id,
            "trace_id": trace_id,
            "status_publisher": self._telemetry.publish_status,
        }

        result = await self._planner.run(
            query=query,
            llm_context=llm_context,
            tool_context=tool_context,
        )
        if isinstance(result, PlannerPause):
            raise {{ class_name }}FlowError("Planner paused unexpectedly")
        if not isinstance(result, PlannerFinish):
            raise {{ class_name }}FlowError("Planner did not finish successfully")

        payload: Any = result.payload
        documents: list[str]
        if isinstance(payload, FinalDocuments):
            documents = payload.documents
        elif isinstance(payload, dict):
            if "documents" in payload:
                docs = payload.get("documents") or []
                documents = [str(item) for item in docs] if isinstance(docs, list) else [str(docs)]
            elif isinstance(payload.get("join"), dict):
                join_obs = payload["join"].get("observation") or {}
                docs = join_obs.get("documents", [])
                documents = [str(item) for item in docs] if isinstance(docs, list) else [str(join_obs)]
            else:
                documents = [str(payload)]
        else:
            documents = [str(payload)]

        answer_text = ", ".join(documents)

        await self._memory.ingest_interaction(
            tenant_id=tenant_id,
            user_id=user_id,
            session_id=session_id,
            user_prompt=query,
            agent_response=answer_text,
        )

        return AgentResponse(
            answer=answer_text,
            trace_id=trace_id,
            metadata=dict(result.metadata),
        )

    async def stop(self) -> None:
        """Graceful shutdown hook."""
        if self._started:
            self._started = False
            _LOGGER.info("{{ project_name }} orchestrator stopped")
